rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Comments collection
    match /comments/{commentId} {
      // Allow read access to all approved comments
      allow read: if resource.data.approved == true;
      
      // Allow authenticated users to create comments
      allow create: if request.auth != null 
        && request.auth.uid != null
        && validateComment(request.resource.data);
      
      // Allow users to update their own comments (for moderation status)
      allow update: if request.auth != null 
        && request.auth.uid == resource.data.userId
        && onlyUpdateAllowedFields(request.resource.data, resource.data);
      
      // Allow admin users to update any comment (for moderation)
      allow update: if request.auth != null 
        && request.auth.token.admin == true;
      
      // Allow admin users to delete comments
      allow delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Artwork panels collection
    match /artworkPanels/{panelId} {
      // Allow read access to all artwork panels
      allow read: if true;
      
      // Only admin users can create, update, or delete artwork panels
      allow create, update, delete: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Users collection
    match /users/{userId} {
      // Users can read and write their own data
      allow read, write: if request.auth != null 
        && request.auth.uid == userId;
      
      // Admin users can read all user data
      allow read: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // User activities collection
    match /userActivities/{activityId} {
      // Users can create their own activities
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId;
      
      // Admin users can read all activities
      allow read: if request.auth != null 
        && request.auth.token.admin == true;
    }
    
    // Analytics collection (admin only)
    match /analytics/{document=**} {
      allow read, write: if request.auth != null 
        && request.auth.token.admin == true;
    }
  }
  
  // Function to validate comment data
  function validateComment(commentData) {
    return commentData.keys().hasAll([
      'text', 'language', 'position', 'year', 'timestamp', 'userId', 'approved', 'metadata'
    ]) &&
    commentData.text is string &&
    commentData.text.size() > 0 &&
    commentData.text.size() <= 500 &&
    commentData.language is string &&
    commentData.language.size() <= 10 &&
    commentData.position is map &&
    commentData.position.keys().hasAll(['x', 'y']) &&
    commentData.position.x is number &&
    commentData.position.y is number &&
    commentData.position.x >= 0 &&
    commentData.position.x <= 1 &&
    commentData.position.y >= 0 &&
    commentData.position.y <= 1 &&
    commentData.year is int &&
    commentData.year >= 2000 &&
    commentData.year <= 2009 &&
    commentData.timestamp is int &&
    commentData.timestamp > 0 &&
    commentData.userId is string &&
    commentData.userId == request.auth.uid &&
    commentData.approved is bool &&
    commentData.metadata is map &&
    commentData.metadata.keys().hasAll(['device', 'inputMethod', 'sessionId']) &&
    commentData.metadata.device in ['mobile', 'tablet', 'desktop'] &&
    commentData.metadata.inputMethod in ['touch', 'keyboard', 'stylus'] &&
    commentData.metadata.sessionId is string;
  }
  
  // Function to check if only allowed fields are being updated
  function onlyUpdateAllowedFields(newData, existingData) {
    return newData.keys().hasAll(existingData.keys()) &&
           newData.keys().hasOnly(existingData.keys()) &&
           newData.text == existingData.text &&
           newData.language == existingData.language &&
           newData.position == existingData.position &&
           newData.year == existingData.year &&
           newData.timestamp == existingData.timestamp &&
           newData.userId == existingData.userId &&
           newData.metadata == existingData.metadata;
  }
}